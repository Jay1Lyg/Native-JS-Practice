<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>setTimeout&setInterval</title>
    <script type="text/javascript">
    window.onload = function() {
    	//关于 setTimeout() 和 setInterval() 的区别和联系，我一直没有做过详细研究，我印象中记得 setInterval() 会比较费内存或者对性能不是很好，然后 setTimeout() 内部再嵌套 setTimeout() 可以实现 setInterval() 的效果。但是具体关于这两个方法，没有做过详细研究。在找相关资料的过程中，发现了一篇和异步有关的文章。

        //http://www.tuicool.com/articles/Ebueua，文章对 setTimeout() 和 setInterval() 有比较详细的说明，解释的还不错
        //关于这两个概念，从文章中收获最大的就是他们两个的真正含义，表示的并不是延迟多少毫秒或者每隔多少毫秒之后执行第一个参数的函数，而是延迟多少毫秒或者每隔多少毫秒之后就将函数放入执行队列中，文中对于这个概念的描述如下：

        //======= quote start ===========
        //setTimeout：在指定的毫秒数后，将定时任务处理的函数添加到执行队列的队尾。
        //setInterval：按照指定的周期(以毫秒数计时)，将定时任务处理函数添加到执行队列的队尾。
        // setTimeout 与 setInterval 都是异步的，其实调用setTimeout时候，会有一个延时事件排入队列，然后会先调用setTimeout之后的代码，接着是再下一行代码，直到再也没有任何代码了，javascript虚拟机才会问，队列里还有吗？如果队列中至少有一个事件适合于触发，比如上面的setTimeout函数，则会调用setTimeout那个函数。
        //我们再来看看下面的函数，如下：
        // setTimeout(function(){
        // console.log("打印我，我是异步执行的");
        // },100);
        // console.log("我是新来的，我要先执行");
        // 运行结果是：先打印出 “我是新来的，我先执行”这句代码，接着打印”打印我，我是异步执行的”代码。
        //======= quote end ===========

        //如果你还没有理解异步的意思的话，我们将上面一段代码修改一下，然后再看看结果

        // setTimeout(function() {
        // console.log("打印我，我是异步执行的")
        // }, 0);

        // console.log("我是新来的，我要先执行");
        // console.log("我是新来的，我要先执行");
        // console.log("我是新来的，我要先执行");
        // console.log("我是新来的，我要先执行");
        // console.log("我是新来的，我要先执行");
        // console.log("我是新来的，我要先执行");
        // console.log("我是新来的，我要先执行");
        // console.log("我是新来的，我要先执行");
        // console.log("我是新来的，我要先执行");
        // console.log("我是新来的，我要先执行");
        // console.log("我是新来的，我要先执行");
        // console.log("我是新来的，我要先执行");

        //你会发现，如果你不从异步的角度理解，而仅仅从延迟多少秒之后去执行这样的意思去理解 setTimeout() 和 setInterval() 的话，你根本无法预测上面的执行结果。因为按照错误的理解方式，上面的代码表示 0 秒之后打印 "打印我，我是异步执行的"，0 秒后执行也就意味着立即执行，也就是应该先打印“异步”，再打印“新来的”。可事实上，上面这段代码的执行结果是：把所有的 “我是新来的，我要先执行” 打印完之后，才打印了 "打印我，我是异步执行的"，无论这个后面有多少个 "我是新来的，我要先执行"，也尽管 setTimeout() 的第二个参数是 0，都不会影响最后的结果。

        //对于同步和异步，我们通过一个比喻来理解可能更为直观和形象。同步表示按照顺序一个个来，你前面的执行完了你才可以执行，你不可以跳过前面的去执行。但是异步则意味着排在我后面的事情可以先执行，也意味着我们有可能排成两个队伍，形成并列关系（也许这就是多线程的意思？），当在同步的队列中有很多异步的时候，这些异步就会形成一个和大队伍并列的等待队列。形象一点的话，这就表示，执行到我这里的时候，我和我后面的所有执行队列成为了并列关系，我会一直排在这个大队伍的旁边，成为旁边一个等待时间一到就插入队伍最前面的人，到了时间点我就会立即插进队伍中去。
        //大概的情况就相当于，你在排队等待打印火车票，火车票只能在发车前 30 min 打印，你到达打印机的时间是发车前 31 min ，这个时候你是无法打印火车票的。而你后面的人的火车出发时间都是 30 分钟之内，所以你自己给自己设定了一个倒计时，或者叫定时器———1分钟之后你打印自己的火车票，即 setTimeout(function() {console.log("打印火车票");}, 1000*60)，而你并不需要重新去排到队伍的最末尾或者干脆因为你没到时间就让你错过打印车票这件事情。然后你就站在队伍的最前面的旁边，和旁边的队列形成了两个纵列，你们之间是并排或者叫并列的关系。并排之后，排在你后面的人会先打印他们的车票（排在后面的比排在前面的先执行），一旦到了延迟 1 min 这个时间点，你就立即插入队伍的最前面打印自己的火车票。这样做的好处是既没有影响后面的人按顺序执行，也没有影响你的执行（没有让你重新等待，或者让你错过执行），只不过是让你按照规定的时间等待了一会儿然后再执行。

        //我们再来理一下编程中异步的思路：遇到异步，先放着不执行，而是执行后面的代码，执行到一定的时间之后再让你插入到队列中。其实并不是上面链接文章中说的放到队尾，放到队尾的说法也不太好理解，因为你也不知道什么时候到时间，你无法预知整个大队伍哪个函数是执行的队尾，你也就无法准确地将这个异步函数放入真正的相对队尾。还是放在旁边到时间之后再插入队伍最前排这样的描述和理解更准确，更让人容易理解。

        //这样的话，这个异步也意味着，并不是异步在前的就一定先执行，异步在后的就一定排在后面，也要看谁先到时间点，例如下面的例子：
        // setTimeout(function() {console.log("异步的1");}, 1000*60*60);
        // console.log("同步的");
        // console.log("同步的");
        // setTimeout(function() {console.log("异步的2");}, 1);
        // console.log("同步的");
        // console.log("同步的");
        // console.log("同步的");

        //第一个异步要一小时后才可以打印，而第二个异步只需要稍等片刻就可以打印，那么当然是第二个异步先于第一个异步打印！就好像你提前一个小时到了车站，不让你进站，而你后面有一些可以立即进站的人，这些人在进站的过程中，又遇到一个可以先让后面的人先进站，自己稍等片刻就可以进站的人。这个时候当然是他排在你前面，和你一起构成了大队伍旁边的一个并列的小队伍，只不过尽管在排大队伍的时候他在你后面，但是当排这个小队的时候，他还是排在你前面，因为他马上就可以进站了，而你还要等待一小时减去你之前等待的时间之后才可以进站。排成这样的小队之后，后面可以立即进站的人进完之后，他就赶紧插入到队伍中进站，而你还要等上很久才可以进站。用这样的事例来解释或者说明关于异步这件事情的话，印象会形象一些，也会稍微深刻一些。
    };
    </script>
</head>

<body>
</body>

</html>
